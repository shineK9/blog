---
title: 前端工程化
draft: false
banner: '/HFUAjfbamNhbM8dsNSQW3D.jpg'
description: 在学习web开发相关的知识时，我们经常会听到一个词叫“前端工程化”。它经常出现在介绍构建工具的博客文章下面，往往作者会像报菜名一样列举一堆 Webpack 或者 Rollup 的插件，最后说使用这些插件让我的前端项目更加的工程化。但是“工程化”这个词，很少有人会对它做出解释，以及为什么要“前端工程化”？本文将尝试对“前端工程化”一词提出自己的理解，以及实际应用。
tags: '工程化,编译'
createOn: '2023-2-27'
---

## 软件工程

在搞懂“前端工程”前，我认为我们先要搞懂什么是“软件工程”？
web 前端是软件领域的一个分支，只有把“软件工程”彻底搞懂了，
我们才能真正的理解前端工程是在做什么。

假设你是一个软件项目的负责人，你有一个超大型的软件系统需要开发，它有严格的时间限制，
暂时不考虑人力成本，你应该怎么做才能顺利完成它？

这是软件工程师弗雷德实际遇到的问题，上世纪 60 年代，那个时期对于软件工程还没有什么概念，
但是弗雷德需要管理公司的一万名软件工程师进行 System/360 系统的开发，系统最后完成了，
但是却逾期很久。事后，弗雷德总结之前的失败经历，写出了《人月神话》一书，
这本书后来成为大众公认的研究软件工程的第一本书。翻开这本书，你会发现，整本书基本上都是
围绕如何管理一个大型软件的开发展开的，讲述自己根据多年经验总结出来的方法论，
探讨了如何进行进度管理、团队组织、系统设计、软件架构等多个方面。
这里每个方面，可能都可以算作软件工程的一部分，所以，软件工程是一门综合性很强的
学科，很难用一句简单的话概括整个软件工程。

打开维基百科，你也会发现软件工程的定义一直在变，没有一个权威公认的定义，
有一个比较全面的定义是电气工程师协会(IEEE)在 1933 年给出的：
> 将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中。

结合维基百科的定义，和《人月神话》里面讲到的内容，我也简单给出我个人对软件工程的理解——
研究在可控成本，可控软件复杂度的情况下完成软件开发的学问，就是软件工程。

## 前端工程化

在知道什么是软件工程后，前端工程是什么自然不言而喻，它就是软件工程在前端领域上的实践。
在 Web 开发的历史中，最开始是不需要所谓前端工程的，那个时候页面被设计出来的初衷仅仅
是展示文档，最多也就让用户填几个表单，交互性内容很少。
后来随着 Web 技术的火速发展、JavaScript 脚本的加入，
Web 平台显现出很多桌面平台所不具备的优势，比如开箱即用、跨平台，
这些特性让很多互联网公司都首选了 Web 平台。

典型的有 Facebook/Amazon，他们的业务基本上都是部署在 Web 平台上面。
随着这些公司业务的扩张，
前端应用变得越来越复杂，如果还是使用粗糙的管理方式，那么将会面临严重的项目失控，
导致软件的开发速度跟不上公司业务的发展，这对于互联网公司是灾难性的。
所以，为了解决这一问题，这些早期的互联网公司总结了很多前端工程方面的思想和实践。
本着程序员热爱技术开源的原则，大家在互联网上分享自己对于复杂前端项目的解决方案，
早期以 JQuery/Dojo 这样的工具库为主，它们一定程度上降低了前端项目的复杂度，
但是都有些治标不治本，人们没有直视前端工程化缺失的问题，
代码的复用性依旧很差，视图和业务代码互相耦合。直到后面出现了一个新型的前端解决方案，
来自 Facebook 的 React UI 库扭转了这一局面。React 先驱式的提出了组件式、MVC 架构、JSX
等工程性很强的概念，基本上颠覆了当时很多人对前端领域的认知，大家意识到前端也可以更加的工程化。

## 如何落地?

我们既然知道了工程化的作用，以及为什么前端需要工程化，那么剩下的就是搞清楚如何将前端
工程化落地到真实项目当中以及如何衡量项目是否足够工程化？

为此，在这里可以把前端工程的落地看做是在解决下面这些问题：

1. 如何提高开发效率?
2. 如何降低代码复杂度?
3. 如何使项目可以持续维护?

我们可以认为，只要是解决这些问题的技术，就是是前端项目工程化的技术。

## 组件化

我们从传统的页面开发模式说起，通常会将页面构建分为三个部分：

1. 在 `.html` 文件中编写 HTML 代码用以描述视图结构。
2. 在 `.css` 文件中编写 CSS 代码用以描述视图中元素的样式。
3. 在 `.js` 文件中编写 JavaScript 代码用来绑定页面的交互事件。

乍一看，似乎还挺清晰的，代码根据各自的功能组织在同一个文件当中，
但是实际中这样的设计其实存在一个很大的工程缺陷。我们知道，软件开发往往是多人协同，
同一个页面，可能有多个人贡献代码，举个例子：
假设今天有一个需求 A，程序员小红为此编写了
一些代码段放入了对应的三个文件中，此时三个文件的内容可能是这样：

``` text
.html
A的业务代码块1
A的业务代码块2

.css
A的业务代码块1
A的业务代码块2

.js
A的业务代码块1
A的业务代码块2
```

第二天，有一个需求 B，安排程序员小明编写了一些新的代码，然后随缘的插入到三个文件的不同位置上。

``` text
.html
A的业务代码块1
B的业务代码块1
B的业务代码块2
A的业务代码块2

.css
A的业务代码块1
B的业务代码块1
A的业务代码块2
B的业务代码块2

.js
B的业务代码块1
A的业务代码块1
B的业务代码块2
A的业务代码块2
```

第三天，有一个需求 C，安排程序员小王编写了一些新的代码，他把代码都插入到三个文件的头部。

``` text
.html
C的业务代码块1
C的业务代码块2
A的业务代码块1
B的业务代码块1
B的业务代码块2
A的业务代码块2

.css
C的业务代码块1
C的业务代码块2
A的业务代码块1
B的业务代码块1
A的业务代码块2
B的业务代码块2

.js
C的业务代码块1
C的业务代码块2
B的业务代码块1
A的业务代码块1
B的业务代码块2
A的业务代码块2
```

第四天，需求 A 发生了改变，之前关于 A 的业务代码都需要修改，小红只要再次打开了之前的文件，
然而她直接傻眼了，自己之前写的那些代码段已经穿插在别人的代码中了，想要修改，
她又得重新阅读一遍整个文件中的代码，找出来自己写的部分。

以此类推下去，后面每一次页面的修改，都可能需要重新阅读整个页面的代码，这就是传统开发模式的弊端，
随着页面的不断修改，维护的成本也会不断上升。

React 是一个 Facebook 开源的前端 UI 库，用于构建用户界面。
与传统方案不同的是，它提供了一个叫做组件的玩意，
组件可以理解为页面上的一个个功能块。
比如：搜索框、导航栏、新闻列表。React 的页面是一个个组件堆砌在一起组成的，
组件内部维护它自己功能相关的代码，包括：视图结构、样式、交互逻辑。

假设还是上面的例子，想要实现业务 A、B、C，代码的组织形式会变成这样：

```text
a.jsx
A的业务代码块1
A的业务代码块2
A的业务代码块3
A的业务代码块4
b.jsx
B的业务代码块1
B的业务代码块2
B的业务代码块3
B的业务代码块4
c.jsx
C的业务代码块1
C的业务代码块2
C的业务代码块3
C的业务代码块4
```

我们可以看到，每个人各自的需求都在对应的 `.jsx` 文件中维护，需求发生变化时，
只需要找到需求对应的组件，修改内部代码即可，不再需要去阅读很多无关代码了。

有一条软件开发的原则——开闭原则，是指当我们设计软件时，尽量把做同一件事情的代码
组织在一块，只暴露出对外使用的接口，所以细节全部封闭起来，这样能做到修改自由。
组件化的思想，其实就是开闭原则的体现，我们根据业务或者功能把前端页面上的元素
封装成一个个组件，这些组件只暴露一个简单的接口。
```typescript
// menu.jsx
// React 定义组件的一个简单案例
import './menu.css'

function Menu() {
	const menus = [/* menu items */]

  return (<ul>
	  <li v-for="item in menus" :key="item">{{item}}</li>
	</ul>)
}

export default Menu

// 如何使用它？
// 导入组件
import Menu from './menu.jsx'

// 主页面
function App() {
  return (<div>
	  <!-- 将 menu 挂载到页面上-->
	  <Menu/>
	</div>)
}
```
如果你理解了上面的代码，App 和 Menu 没有代码上的关联，它们相互独立，各自维护自己的代码，
只需要简单的一行导入语句，就能在自己的代码里使用对方的工作成果。

组件化的设计方式，是强工程性的一种设计，它降低了局部代码的复杂度，这点很容易理解，
人更容易理解连贯、有逻辑性的事物。它也提高了前端开发的效率，符合开闭原则的设计，会
让代码很容易复用，复用性提高了，就能减少重复性的工作，借此提高了效率。

## Webpack

Webpack 是一个前端构建工具，它负责把项目源代码转换成浏览器上可执行的文件。
类似于编译器，但是它不是只针对某种特定语言或者技术，
它支持多种高阶语言的输入，比如：Sass/TypeScript/JSX，甚至是图片资源，
然后把他们转换成浏览器可以解析的文件，比如：CSS/HTML/JavaScript。可以参考下图： ![webpack description](/webpack-desc.png)
为什么提 Webpack？因为它让前端技术的发展速度，不受限于 Web 标准的跟进速度。
对于技术标准的制定，它必然是比较缓慢，谨慎保守的。因为 Web 技术几乎应用在世界上每一台
个人电脑上，试错的成本太高了，
可以参考 TC39 (JavaScript标准的工作组)的标准[制定流程](https://nitayneeman.com/posts/introducing-all-stages-of-the-tc39-process-in-ecmascript/)。
如果所有新技术的应用都要通过这些标准化组织，那么现在的前端技术体系，可能要几十年后才能达成。
Webpack 是插件式的，可以把它理解成一个平台，你可以自己发明一个新技术，然后开发一个 Webpack 插件，
就等于把它发不到了 Webpack 平台上，所有使用 Webpack 的人，就能
在自己的开发流程中使用你的技术。这是一个非常低成本的过程，这意味着你可以激进的
发布新技术，然后让大家来给你试错。好的技术会在这个过程中被保留下来，不好的技术则被淘汰掉，
这相当于给 Web 技术的进化过程打了一针催化剂。

## JS 的模块化

现在几乎所有的工业语言，它都会有一个强大的模块化系统。模块化可以让你更灵活的组织代码，
把工程化的概念应用到你的项目中。作为 Web 开发的主力语言——JavaScript，早期的时候
它缺少一个强大的模块化系统的，所有文件里的变量、函数，全部共享一个全局作用域，
这样简单的设计，会让我们的系统充满不稳定。早期的时候，人们也做出过一些努力，比如发明
一个第三方模块系统，比如：AMD(Asynchronous Module Definition)。他要求人们如此定义
一个模块:

```js
// messages.js
define(function () {
    // 通过 return 导出模块
    return {
        getHello: function () {
            console.log('Hello World')
        }
    }
})
```

然后通过 `require()` 去使用模块：

``` js
define(function (require) {
    // 引用 messages 模块
    var messages = require('./messages')

    messages.getHello()
})
```

这种方式借助闭包实现的模块化机制，解决了一些标准模块下的弊端，比如：文件间的变量被限制在自己的
作用域下，只导出自己想导出的模块。但是也带来一些问题，比如：模块的加载顺序问题；会产生一些运行时
开销；不兼容其它的模块系统。

2009年，一款新的 JavaScript 运行时在当年的 JSConf 大会上被发布，
它突破了浏览器的限制，可以直接进行 IO 操作，
包括 Webpack 等众多 JavaScript 生态链工具都是运行在它上面的。
NodeJS 同时发明了一种新的模块系统——CommonJS，它应该是 JavaScript 的第一款现代化模块系统。

CommonJS 中的变量不会默认挂载在全局对象上，每个`.js`文件都有自己独立的作用域，
你可以通过`module.exports`去导出模块，使用`require`引入模块。
```
// a.js
const B = require('./b.js')
B.sayHello()

// b.js
function sayHello () {
  console.log('hello')
}

module.exports = {
  sayHello
}
```

直到今天，CommonJS 依旧作为主流的 JavaScript 模块系统被使用。相比 AMD，
CommonJS 是 NodeJS 原生支持的，同时它避免了啰嗦的闭包式写法，简洁明了。
不过 CommonJS 有也它的缺点，浏览器环境不支持，require 的语法不好做静态分析，
导致很难实现[Tree shaking](https://webpack.docschina.org/guides/tree-shaking/)这样的技术。

::Card{title="小贴士"}
前面说了，Webpack 是让我们提前使用到新技术的加速器。虽说浏览器不支持 CommonJS，
但是我们依旧可以在我们的项目中使用 CommonJS，借助 Webpack 的编译功能，CommonJS
的语法可以被转变为浏览器支持的语法。
::

2015 年，ECMA 组织发行了一个很重要的 JavaScript 版本——EcmaScript 6，简称 ES6。
ES6 添加了很多好用的语言特性，其中包括了官方的模块语法。
```js
// a.js
import { sayHello } from './b.js'

sayHello()

// b.js
export function sayHello() {
  console.log('hello')
}
```

相比 CommonJS，ES6 的模块设计有着更好的工程特性。它可以被更好的分析文件依赖关系，
更好的判断导入、导出的函数和变量，更容易的实现 `Tree Shaking`。

至此，JavaScript 的模块系统发展告一段落。一个好的模块系统，是做到前端工程化的必要条件，
人脑对于复杂度的处理能力是有限的，当一个软件系统不断的添加功能，那么它将变得无法继续维护。
通过合理利用模块系统，可以将这样一个不断膨胀的软件系统，划分成一个个相对独立的子系统、子模块，
从而大大延长软件的可维护周期。

## 类型系统

## 建立规范

## 管理源码
